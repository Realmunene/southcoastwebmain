class Admin < ApplicationRecord
  has_secure_password

  # --------------------
  # Role mapping (matches schema)
  # 0 = super_admin
  # 1 = admin
  # --------------------
  enum role: {
    super_admin: 0,
    admin: 1
  }

  # --------------------
  # Validations
  # --------------------
  validates :email, presence: true, uniqueness: true
  validates :role, presence: true

  validates :password,
            length: { minimum: 6 },
            if: -> { new_record? || password.present? }

  validate :strong_password
  validate :single_super_admin, if: :super_admin?

  # --------------------
  # Defaults
  # --------------------
  after_initialize :set_default_role, if: :new_record?

  def set_default_role
    self.role ||= :admin
  end

  # --------------------
  # Ensure only one super admin exists
  # --------------------
  def single_super_admin
    if Admin.super_admin.where.not(id: id).exists?
      errors.add(:role, "There can only be one Super Admin in the system.")
    end
  end

  # --------------------
  # Password Reset
  # --------------------
  def generate_password_reset_token!
    self.reset_password_token = SecureRandom.urlsafe_base64
    self.reset_password_sent_at = Time.current
    save(validate: false)
  end

  def reset_password_token_valid?
    reset_password_sent_at && reset_password_sent_at > 1.hour.ago
  end

  def reset_password(new_password, confirmation)
    if new_password != confirmation
      errors.add(:password_confirmation, "doesn't match Password")
      return false
    end

    unless new_password.match?(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[^\w\d]).+$/)
      errors.add(:password, "must include upper, lower, digit, and special character")
      return false
    end

    self.password = new_password
    self.password_confirmation = confirmation
    self.reset_password_token = nil
    self.reset_password_sent_at = nil

    save
  end

  # --------------------
  # Helpers
  # --------------------
  def active?
    true # replace when logic exists
  end

  private

  # --------------------
  # Strong password policy
  # --------------------
  def strong_password
    return if password.blank?

    unless password.match?(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[^\w\d]).+$/)
      errors.add(:password, "must include upper, lower, digit, and special character")
    end
  end
end
